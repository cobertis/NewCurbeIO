Act as a Senior Backend Architect. We are building a critical Microservice for WhatsApp communication within a CRM for Insurance Agents.

We are starting from scratch (Clean Slate).
TARGET ENVIRONMENT: Replit (Node.js + TypeScript).
DATABASE: PostgreSQL (Available in Replit environment via `pg`).

### CORE OBJECTIVE
Implement a robust, production-ready WhatsApp connection using `@whiskeysockets/baileys`.
The system must handle high-volume messaging, maintain session persistence across server restarts, and synchronize chat history reliably to the database.

### STRICT TECHNICAL CONSTRAINTS (Do Not Violate)
1. LIBRARY VERSION: You MUST install and use `@whiskeysockets/baileys@^6.7.0`. DO NOT use v7.0.0-RC versions as they are unstable for production.
2. NO IN-MEMORY STORE: You are strictly FORBIDDEN from using `makeInMemoryStore`. Storing chats in RAM causes OOM (Out of Memory) crashes on Replit. All data must flow directly to PostgreSQL.
3. NO FILE SYSTEM AUTH: Do not use `useMultiFileAuthState` storing JSONs in the local disk, as Replit containers are ephemeral. You MUST implement a Custom Auth Strategy that saves and retrieves session credentials (creds + keys) from a PostgreSQL table (e.g., `whatsapp_sessions`).

### IMPLEMENTATION STEPS

#### 1. Database Schema (PostgreSQL)
Create a script to initialize the necessary tables:
- `auth_keys`: To store the Baileys session mechanism (id, data JSON).
- `chats`: To store contact info and conversation metadata.
- `messages`: To store individual messages (id, remoteJid, fromMe, body, timestamp, status). UNIQUE constraint on message ID to prevent duplicates.

#### 2. The WhatsApp Service (Class-based)
Create a TypeScript class `WhatsAppService` that handles:
- **Connection Logic:** Implements `makeWASocket` with the custom DB Auth state.
- **QR Code:** Generates the QR code string. If possible, use `qrcode-terminal` for logs AND expose the QR data via a getter so the frontend can display it later.
- **Reconnection:** Implement robust reconnection logic for `connection.update` (handling `DisconnectReason.loggedOut` vs temporary disconnects).

#### 3. Message Handling (The Critical Part)
- Listen to `messages.upsert`.
- **Logic:** Iterate through incoming messages.
- **Filter:** Ignore protocol messages if they don't carry content.
- **Persistence:** UPSERT (Insert or Update) the message immediately into the PostgreSQL `messages` table. Do not buffer in RAM.
- **History Sync:** Ensure that when a new session connects, the initial history dump is processed and saved to the DB efficiently.

#### 4. API Endpoints (Express)
Create a simple Express server with these routes:
- `GET /status`: Returns connection status (QR waiting, Connected, Disconnected).
- `POST /send-text`: Accepts `{ number, message }` and sends a text message.
- `POST /send-media`: Accepts `{ number, url, caption, type }` and sends media.

### CODE STYLE
- Use TypeScript with strict typing.
- Use `pg` (node-postgres) for database interactions.
- Add detailed comments explaining the logic, especially in the Auth Adapter.
- Handle errors gracefully (try/catch) to prevent the process from crashing.

Proceed to generate the project structure, the SQL schema, and the full TypeScript code implementation.