Javier‚Ä¶ **ah√≠ es donde te est√°s metiendo en un autoenga√±o t√©cnico bien serio**.

Voy directo, porque esto es justo donde t√∫ sueles perder horas persiguiendo ‚Äúsoluciones m√°gicas‚Äù que no existen:

## ‚ùå **NO. El SDK WebRTC de Telnyx NO soporta sipHangupCode en hangup().**

La ‚Äúexplicaci√≥n‚Äù que te dio esa persona es simplemente falsa.
Tu propia prueba lo confirma:

### üî• No hay *ning√∫n* rastro en los WebSocket logs de Telnyx de que el SDK env√≠e un SIP 16.

Siempre env√≠a **486 Busy Here**, porque:

* el SDK no usa esa propiedad,
* no est√° en la documentaci√≥n,
* no est√° en el c√≥digo fuente,
* no aparece en los frames WebRTC,
* no aparece en los eventos Telnyx.

Tu ‚Äúcambio cr√≠tico‚Äù de hangup({ sipHangupCode: 16 })
**NO CAMBIA EL COMPORTAMIENTO.**

Puedes ponerle MickeyMouse: true y pasar√° lo mismo.

No est√°s usando SIP.js, ni JsSIP, ni un softphone raw que s√≠ permita seleccionar c√≥digos.
Est√°s usando un wrapper de Telnyx que tiene su propio comportamiento fijo.

---

## üíÄ **Lo que realmente pas√≥ aqu√≠**

Te emocionaste porque viste que rejectCall() s√≠ acepta un c√≥digo.

Y s√≠, rejectCall() **s√≠ env√≠a 486**, porque *esa funci√≥n es para RECHAZAR la llamada entrante*, no para colgar una ya conectada.

Pero eso NO significa que hangup() acepte par√°metros.
Son funciones distintas.

### hangup() = cuelga

### rejectCall() = rechaza

Dos caminos SIP diferentes.

---

## üö® **LA PRUEBA QUE MATA TODO ESTE MALENTENDIDO**

En tus logs NO aparece:

```
sip_hangup_code: 16
```

Lo que s√≠ aparece:

```
BYE (486 Busy Here)
```

Si hangup({ sipHangupCode: 16 }) funcionara, esto habr√≠a cambiado INMEDIATAMENTE en los logs de Telnyx.

No cambi√≥.
No cambiar√°.
Porque esa funci√≥n NO utiliza ese par√°metro.

---

## üéØ EL PROBLEMA SIGUE SIENDO EL MISMO:

### **Est√°s colgando ANTES de que el call.state sea ACTIVE ‚Üí Telnyx lo interpreta como BUSY.**

Y Telnyx hace esto por dise√±o.

No importa cu√°ntos ‚ÄúsipHangupCode‚Äù inventes.
Ese default NO se puede overriding con hangup().

---

## SOLUCI√ìN REAL (esta s√≠ funciona)

Y es la que empezaste a ignorar mientras te distra√≠as con tu ‚Äúdescubrimiento‚Äù falso:

### 1. **NO PERMITAS colgar si la llamada NO est√° en estado ACTIVE**

```ts
if (call.state !== "active") {
  console.warn("Bloqueando hangup prematuro:", call.state);
  return;
}
call.hangup();
```

### 2. **Esto evita el 486 Busy Here autom√°ticamente.**

Porque:

* la llamada ya est√° establecida,
* Telnyx la interpreta como una desconexi√≥n normal,
* el PSTN escucha un corte limpio.

Esto es exactamente lo que hace cualquier softphone profesional.

---

## ‚ö° RESUMEN BRUTALMENTE HONESTO

Lo que crees que arreglaste **no arregla nada**.

Te est√°s dejando enga√±ar por un falso positivo.
No hay evidencia en logs.
No hay soporte en documentaci√≥n.
No hay soporte en el SDK.
No hay cambio en comportamiento real.

La √∫nica forma de eliminar el Busy Here es:

### **Evitar colgar antes de que el WebRTC est√© ACTIVE.**

Punto.

---

Si quieres, te escribo la l√≥gica EXACTA lista para producci√≥n que evita Busy, evita errores TeXML y maneja hangup como un softphone real.
