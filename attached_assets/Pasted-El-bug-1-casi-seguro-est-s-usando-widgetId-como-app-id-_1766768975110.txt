El bug #1 (casi seguro): estás usando widgetId como “app_id”

Tú guardas:

curbe_device_id:${widgetId} en localStorage
y tu bootstrap es:

/api/messenger/bootstrap?widgetId=xxx&deviceId=xxx

Eso significa: si el widget cambia (otro widget, otro dominio, otro tenant, otro embed, otro environment), nace otra identidad. Intercom no hace eso: usa un identificador estable por “app/tenant”, no por widget.

Consecuencia directa:

“no guarda los viejos”

“no abre chat nuevo” (porque el backend no está encontrando el device/contact correcto)

“sesiones raras” (porque tu conversación no está anclada a un contact estable)

Fix real: el device id debe ser por tenant/company, no por widget.

key correcta: curbe_device_id:${companyId} o curbe_device_id:${tenantId}

widgetId solo para config/targeting, no para identidad

El bug #2: “session” vs “conversation” están desalineados

Tú dices:

DB tiene conversations

pero el flujo “Nuevo Chat” crea /api/live-chat/sessions

y el WebSocket se conecta a /ws/live-chat/:sessionId

Si sessions NO crea/actualiza un registro en conversations (o no lo enlaza al contact_id del device), entonces:

el widget cree que tiene “historial”

el backend realmente no puede reconstruirlo

el tab “Messages” muestra basura o vacío

“nuevo chat” puede fallar porque “open conversation” nunca existe donde estás buscando

Fix real: decide UNA verdad:

o renombrar sessions→conversations y que conversation_id = session_id

o crear session pero SIEMPRE crear/actualizar conversations enlazada a contact_id y device_id

El bug #3: tu tabla live_chat_devices está diseñada para fallar

Mira esto:

CREATE TABLE live_chat_devices (
  id VARCHAR PRIMARY KEY,
  device_id VARCHAR NOT NULL,
  company_id VARCHAR NOT NULL,
  widget_id VARCHAR,
  contact_id VARCHAR,
  ...
);


Problemas típicos aquí:

id vs device_id: si en código a veces buscas por id y otras por device_id, tendrás identidades fantasma.

No veo constraints útiles:

debería existir UNIQUE(company_id, device_id) sí o sí

y probablemente INDEX(company_id, widget_id, device_id)

Si permites múltiples filas para el mismo device_id, tu bootstrap devuelve cualquier cosa.

Fix real:

UNIQUE(company_id, device_id)

id puede ser gen_random_uuid() y listo; pero la clave lógica es (company_id, device_id)

El bug #4: estás pasando companyId por query en el WS (y eso es un tiro en el pie)

Tu WS:
/ws/live-chat/:sessionId?widgetId=xxx&companyId=xxx

Si el embed no tiene companyId confiable (y muchas veces no lo tiene), vas a tener:

conexiones “en companyId equivocado”

broadcasts que no llegan porque filtras por ws.companyId === companyId

Fix real: el servidor debe derivar companyId desde widgetId (lookup en DB) o usar un token firmado. No confíes en query params para tenancy.

Qué le dices a Replit (mensaje quirúrgico, sin drama)

Pégales esto:

“Replit: esto no es UI, es data-model. Arreglen estos 6 invariantes.”

DeviceId NO puede depender de widgetId.

Cambiar localStorage key de curbe_device_id:${widgetId} a curbe_device_id:${companyId} (o tenantId).

companyId se obtiene desde /api/public/chat-widget/:id (viene ahí), y luego se usa para device identity.

Bootstrap debe ser determinista y 100% backend-driven.

GET /api/messenger/bootstrap?widgetId=... debe:

resolver companyId por widgetId

leer/crear live_chat_devices con (companyId, deviceId) (UNIQUE)

devolver contactId y lista de conversations por contactId

Unificar “session” y “conversation”.

Al crear /api/live-chat/sessions, obligatoriamente:

crear/actualizar registro en conversations

enlazar conversation.contact_id = live_chat_devices.contact_id

status = open

El widget solo debe mostrar conversaciones desde conversations (no desde sessions aisladas).

Constraints en DB para evitar identidades duplicadas.

ALTER TABLE live_chat_devices ADD CONSTRAINT unique_device_per_company UNIQUE (company_id, device_id);

indexes para búsquedas comunes.

WebSocket tenancy segura.

WS no debe aceptar companyId de query param como source of truth.

Resolver companyId desde sessionId→conversation→companyId o desde widgetId.

Definición correcta de “New chat”.

Si existe conversación open para ese contact: abrirla.

Solo crear nueva si no hay open, o si el usuario explícitamente fuerza “start new conversation”.

Plan de debugging (para que dejen de “adivinar”)

Diles que agreguen logs con un trace_id por visita:

En el widget (console logs, temporal):

widgetId, companyId, deviceId, contactId, conversationId/sessionId

antes/después de bootstrap

antes/después de crear chat

En backend logs:

bootstrap: companyId resolved, deviceId, found_device_row_id, contactId, conversation_ids returned

create session: deviceId, contactId, conversationId created, status

websocket connect: sessionId, resolved companyId, connection added

broadcast: companyId, sessionId, num_connections, sent_ok

Con eso, en 30 minutos queda claro dónde se rompe: casi siempre es identity mismatch o session/conversation no linkeada.