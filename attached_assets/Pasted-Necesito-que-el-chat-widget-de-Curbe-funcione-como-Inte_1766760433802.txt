Necesito que el chat widget de Curbe funcione como Intercom. No es un tema de UI: es un tema de identidad persistente, conversación estable, estados (read/seen/unread) y tiempo real. Implementa lo siguiente en este orden y con estos criterios de aceptación.

1) Identidad persistente (NO sessionId)

Crear device_id (UUID) por tenant y persistirlo en cookie o localStorage:

key: curbe_device_id:{tenantId}

En el backend crear tabla/colección devices:

device_id, tenant_id, contact_id (nullable), last_seen_at

Regla: recargar la página NO debe crear una persona nueva. El mismo device_id debe recuperar el mismo contact_id.

Endpoint

GET /messenger/bootstrap?tenantId&deviceId

Devuelve: contactId, conversaciones abiertas, últimas conversaciones, unreadCount, config.

2) Identify + merge (visitor/lead → user)

Cuando el usuario está logueado en Curbe:

POST /messenger/identify

payload: tenantId, deviceId, userId, email, name + firma (JWT/HMAC) para evitar suplantación

Backend debe:

buscar deviceId → contact previo (visitor)

unir/merge a userId/email (crear/actualizar contacto tipo user)

re-asignar conversaciones del visitor al user (si existían)

Regla: después de login, debe mantener historial del chat previo del mismo dispositivo.

3) Conversación estable (thread), no “sesión”

Crear entidad conversations:

conversation_id, tenant_id, contact_id, status: open/closed, assigned_to, timestamps

Botón “Nuevo chat”:

si existe conversación open -> abrir esa (NO crear otra)

solo crear nueva conversación si:
a) no hay ninguna open, o
b) el usuario elige explícitamente “Start new conversation” y la UI soporta múltiples hilos con lista clara

Endpoints

POST /conversations (solo cuando aplique)

GET /conversations?contactId=...&status=open|recent

4) Mensajes con idempotencia (para evitar duplicados)

En el cliente, al enviar:

generar client_message_id = uuid()

render “pending”

POST /messages

payload: conversationId, client_message_id, body

Backend debe imponer unique(tenantId, conversationId, client_message_id)

Respuesta: message_id, timestamps

Cliente reconcilia pending → sent

Regla: si hay retries o doble click NO debe duplicar el mensaje.

5) Tiempo real bien hecho (SSE o WebSocket)

Implementar canal realtime para:

message.created

conversation.updated

typing

read_state.updated

Requisitos:

Reconnect con last_event_id y resync para no perder eventos.

Si se pierde conexión y vuelve, el chat debe sincronizar y no “desordenarse”.

6) Read vs Seen (como Intercom)

Implementar estados:

read: cuando el usuario abre la conversación → actualiza last_read_message_id/at para ese usuario

seen (lo que se muestra como “visto”): NO se marca solo por abrir el chat en admin.

se marca cuando el agente empieza a tipear o envía respuesta (elige una regla y sé consistente)

7) Feedback/CSAT no rompe el hilo

Feedback debe ser conversation_rating ligado al conversation_id cuando la conversación se marca closed.

No debe crear conversación nueva ni resetear identidad.

Criterios de aceptación (QA obligatorio)

Abrir widget → escribir → cerrar → recargar página → abrir widget: debe mostrar la misma conversación y mismo historial.

Enviar mensaje con internet malo (retry): no hay duplicados.

Login después de haber chateado como visitante: se conserva el hilo (merge funciona).

“Nuevo chat” con conversación open: no crea una nueva.

Dos tabs abiertas: mensajes llegan en ambas sin duplicar y unread cuenta bien.

Reconnect realtime: al volver la conexión, se sincroniza sin perder mensajes.

“Seen” no aparece inmediatamente cuando el agente solo abre; aparece cuando escribe/responde (según regla definida).

Implementa esto y luego recién afinamos UI/animaciones. Si falta cualquiera, no va a sentirse Intercom.