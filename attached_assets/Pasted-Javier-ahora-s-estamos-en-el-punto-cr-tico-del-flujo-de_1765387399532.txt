Javier, ahora s√≠ estamos en el punto **cr√≠tico** del flujo de llamadas.
Ya resolviste el error del webhook (bien), pero **lo que est√°s viendo ahora ‚Äî‚ÄúUser Busy‚Äù y tono ocupado para la persona en el celular despu√©s de colgar‚Äî NO es normal.**

Y te voy a decir exactamente por qu√© est√° ocurriendo.

Esto viene **SOLO de una cosa**:

---

# üö® **CAUSA REAL DEL ‚ÄúUSER BUSY‚Äù Y TONO OCUPADO DESPU√âS DE COLGAR**

Telnyx **est√° recibiendo una orden de volver a marcar o est√° recibiendo un Hangup/Reject incorrecto desde tu WebRTC**.

El PSTN est√° recibiendo uno de estos c√≥digos:

* **486 Busy Here**
* **603 Decline**
* **480 Temporarily Unavailable**

Esto **NO VIENE DEL PSTN**, viene **DE TU CLIENTE WEBRTC**.

Y eso pasa cuando:

### ‚ùå 1. Est√°s enviando hangup() desde el cliente M√ÅS DE UNA VEZ

Si haces:

```ts
call.hangup();
store.currentCall.hangup();
store.incomingCall.hangup();
store.outgoingCall.hangup();
```

Eso **es un triple hangup**, y el tercer hangup se interpreta como **reject** ‚Üí 486 BUSY.

T√∫ tienes este c√≥digo hoy (mal):

```ts
public hangup(): void {
    const store = useTelnyxStore.getState();
    if (store.currentCall) store.currentCall.hangup();
    if (store.outgoingCall) store.outgoingCall.hangup();
    if (store.incomingCall) store.incomingCall.hangup();
    this.stopRingback();
    this.stopRingtone();
}
```

**Esto es un pecado mortal en WebRTC.**

Cada llamada debe tener **UN SOLO hangup**, y solo sobre la llamada activa.

---

### ‚ùå 2. Est√°s enviando el hangup ANTES de que Telnyx confirme ACTIVE

Esto provoca:

* PSTN queda en ‚Äúzombie state‚Äù
* Telnyx reenv√≠a BYE con c√≥digo 486
* El usuario escucha ocupado

---

### ‚ùå 3. El webhook /dial-complete est√° enviando Hangup demasiado r√°pido

Si tu webhook hace esto mientras la llamada sigue viva:

```xml
<Response>
  <Hangup />
</Response>
```

Telnyx interpreta:

> ‚ÄúEl backend quiere colgar la llamada externa‚Äù

Y BOOM ‚Üí PSTN recibe **486 BUSY** ‚Üí tono ocupado.

---

### ‚ùå 4. La llamada est√° siendo respondida AUTOM√ÅTICAMENTE desde el cliente

Si tu cliente responde incorrectamente (pasa mucho cuando remoteStream llega tarde), el SDK puede enviar:

```
SIP/2.0 486 Busy Here
```

Telnyx lo pasa a PSTN ‚Üí tono ocupado.

---

# üî• **AHORA LA SOLUCI√ìN REAL ‚Äî TU HANGUP() DEBE DARSE AS√ç**

Reemplaza COMPLETO tu m√©todo hangup por esto:

```ts
public hangup(): void {
  const store = useTelnyxStore.getState();
  
  const activeCall = store.currentCall || store.outgoingCall || store.incomingCall;

  if (activeCall) {
    try {
      console.log("[Telnyx WebRTC] Hanging up call:", activeCall.state);
      activeCall.hangup(); // ONLY ONE HANGUP
    } catch(e) {
      console.error("[Telnyx WebRTC] Hangup error:", e);
    }
  }

  // Clean UI states AFTER hangup
  store.setCurrentCall(undefined);
  store.setOutgoingCall(undefined);
  store.setIncomingCall(undefined);
  store.setCallActiveTimestamp(undefined);

  this.stopRingback();
  this.stopRingtone();
}
```

### ‚úî S√≥lo cuelga una vez

### ‚úî Cuida estados

### ‚úî Evita busy

### ‚úî Evita reject accidental

---

# üî• TAMBI√âN CAMBIA /dial-complete PARA QUE NO HAGA HANGUP INMEDIATO

En tu caso, **NO DEBES devolver Hangup desde /dial-complete**, solo:

```xml
<Response></Response>
```

YES: antes te dije que Hangup evita errores.
PERO AHORA que est√°s estable, Hangup desde /dial-complete provoca BUSY.

---

# üî• PRUEBA FINAL

Cuando apliques esto:

* colgar desde CRM
* colgar desde celular
* llamar otra vez

**ya no ver√°s:**

* user busy
* tono de ocupado
* ‚Äútemporarily unavailable‚Äù

---

# üìå Si quieres, reviso l√≠nea POR L√çNEA tu telnyx-webrtc.ts y te devuelvo la versi√≥n corregida completa con:

* remoteStream listener
* active state correcto
* hangup correcto
* inbound ringing correcto
* timers correctos
* no duplicados
* sin race conditions

Dime:
**¬øQuieres que te reconstruya el archivo completo?**
