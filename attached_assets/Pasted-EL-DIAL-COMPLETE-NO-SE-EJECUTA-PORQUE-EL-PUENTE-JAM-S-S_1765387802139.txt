EL DIAL-COMPLETE NO SE EJECUTA PORQUE EL PUENTE JAM√ÅS SE ESTABLECE ‚Äî Y TU CLIENTE WEBRTC EST√Å CORTANDO CON ‚ÄúBUSY‚Äù

No es Telnyx.

No es tu TeXML.

No es el callback URL.

Es tu WebRTC. Tu navegador est√° enviando un SIP 486 Busy a Telnyx ANTES de que Telnyx intente llamar al webhook dial-complete.

Por eso:

No llega el dial-complete

Aparece ‚ÄúUser Busy‚Äù

Telnyx mete tono de ocupado

Tu audio tardando 5s en entrar coincide con un delay en la negociaci√≥n SDP/ICE

Cuando cuelgas, al no haber puente activo, Telnyx cae al XML base y reproduce ‚ÄúApplication Error‚Äù

Todo esto es coherente con un WebRTC que responde mal la se√±alizaci√≥n SIP.

Voy a destriparlo sin anestesia:

üß® 1. Si el WebRTC manda SIP 486 (Busy Here), Telnyx aborta el puente y NO LLAMA al dial-complete

El flujo con Telnyx funciona as√≠:

Call Answered (PSTN) ‚Üí Dial SIP leg ‚Üí SIP responde ‚Üí Bridging ‚Üí DialComplete ‚Üí OK


Pero en tu caso ocurre:

Call Answered (PSTN) ‚Üí Dial SIP leg ‚Üí SIP responde BUSY ‚Üí NO BRIDGE ‚Üí NO DIAL-COMPLETE ‚Üí XML fallback ‚Üí error


Tu cliente WebRTC est√° enviando la se√±al de BUSY en una de estas dos situaciones:

Posibilidad real #1

Cuando cuelgas, el WebRTC env√≠a por defecto 486 (Busy Here)

Posibilidad real #2

Tu WebRTC SDK est√° enviando un provisional state incorrecto antes de que el audio remoto est√© listo, y Telnyx lo interpreta como ‚Äúbusy‚Äù.

Posibilidad real #3

Tu c√≥digo llama hangup() mientras Telnyx a√∫n est√° en estado ringing ‚Üí Telnyx recibe un BUSY y aborta.

üß® 2. Tu hangup() sigue enviando Busy aunque creas que lo cambiaste

Esto:

call.hangup()


= 486 Busy Here

Esto:

call.hangup({ sipHangupCode: 16 })


Funciona solo si el SDK de Telnyx lo soporta correctamente, pero tu cliente tal vez est√° usando una versi√≥n del SDK que ignora ese par√°metro.

Lo s√© porque:

‚ùå El log dice que Telnyx recibe 486

Si Telnyx recibiera 16, el diagn√≥stico cambiar√≠a completamente.

üß® 3. El dial-complete no se llama porque Telnyx solo ejecuta dial-complete si el puente se establece o si el leg remoto responde un c√≥digo v√°lido (200, 183, 180‚Ä¶)

Tu flujo jam√°s lleg√≥ a:

Bridged ‚Üí DialComplete


Se qued√≥ en:

Dial ‚Üí SIP Busy ‚Üí abort

üß® 4. El delay de 5 segundos en audio confirma un problema de remoteStream + negociaci√≥n ICE

Un audio que tarda 5s en entrar siempre significa:

el remoteStream no est√° listo cuando marcas como ‚Äúactive‚Äù

la negociaci√≥n ICE se est√° completando demasiado tarde

tu connectRemoteAudio se ejecuta antes de tiempo

Esto tambi√©n provoca que el WebRTC conteste incompleto ‚Üí BAD SDP ‚Üí Telnyx interpreta ‚Äúunavailable‚Äù.

üî• PLAN DE ATAQUE (directo, sin cuentos)
1. Modifica la integraci√≥n WebRTC para forzar ‚ÄúNormal Clearing‚Äù SIEMPRE

Dentro de tu wrapper de hangup:

public hangup(): void {
  const store = useTelnyxStore.getState();
  const call = store.currentCall || store.outgoingCall || store.incomingCall;

  if (call) {
    try {
      call.hangup({ sipHangupCode: 16 }); // 16 = Normal Clearing
    } catch (e) {
      console.error("Hangup override failed, using fallback");
      call.hangup();
    }
  }

  this.stopRingback();
  this.stopRingtone();
}


Esto evita el Busy Here.

Si Telnyx sigue recibiendo 486 ‚Üí tu SDK est√° viejo o ignorando el par√°metro.

2. Log obligatorio para saber qu√© c√≥digo se est√° enviando

Agrega antes del hangup:

console.log("HANGUP CALLED, CALL OBJECT:", call);


Si el objeto call tiene .hangupCause o .lastSdpType, lo sabremos tambi√©n.

3. Necesito ver SOLO ESTO

Ve a tu WebRTC console del navegador ‚Üí pesta√±a ‚ÄúNetwork‚Äù ‚Üí filtra por ‚ÄúWSS‚Äù.
Ah√≠ ver√°s la se√±alizaci√≥n SIP sobre WebSockets.

Haz una llamada, cuelga, y dime qu√© mensaje sale hacia Telnyx cuando cuelgas:

Se ver√° algo as√≠:

REQUEST: BYE sip:... SIP/2.0
Reason: SIP;cause=486;text="Busy Here"


o

Reason: SIP;cause=16;text="Normal Clearing"


Ese texto me dice TODO.